
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com\nazwa\galaxy-empires\buildings.go (0.0%)</option>
				
				<option value="file1">github.com\nazwa\galaxy-empires\config.go (75.0%)</option>
				
				<option value="file2">github.com\nazwa\galaxy-empires\data_base.go (0.0%)</option>
				
				<option value="file3">github.com\nazwa\galaxy-empires\data_player.go (60.0%)</option>
				
				<option value="file4">github.com\nazwa\galaxy-empires\handler_account.go (0.0%)</option>
				
				<option value="file5">github.com\nazwa\galaxy-empires\handler_planet.go (0.0%)</option>
				
				<option value="file6">github.com\nazwa\galaxy-empires\handler_player.go (0.0%)</option>
				
				<option value="file7">github.com\nazwa\galaxy-empires\main.go (0.0%)</option>
				
				<option value="file8">github.com\nazwa\galaxy-empires\middleware_planet.go (100.0%)</option>
				
				<option value="file9">github.com\nazwa\galaxy-empires\middleware_player.go (100.0%)</option>
				
				<option value="file10">github.com\nazwa\galaxy-empires\planet.go (0.0%)</option>
				
				<option value="file11">github.com\nazwa\galaxy-empires\player.go (50.0%)</option>
				
				<option value="file12">github.com\nazwa\galaxy-empires\public_planet.go (0.0%)</option>
				
				<option value="file13">github.com\nazwa\galaxy-empires\public_player.go (0.0%)</option>
				
				<option value="file14">github.com\nazwa\galaxy-empires\resources.go (100.0%)</option>
				
				<option value="file15">github.com\nazwa\galaxy-empires\universe.go (93.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package main

import (
        "fmt"
        "math"
        "time"
)

type BuildingStruct struct {
        ID             string
        Name           string
        Category       string
        Produces       string
        Description    string
        BaseCost       ResourcesStruct
        BaseProduction float64
        Requirements   RequirementsStruct

        CostEquations       EquationStruct
        BuildEqations       EquationStruct
        ProductionEquations EquationStruct

        costTable       []ResourcesStruct
        productionTable []int64
}

func (b *BuildingStruct) PrecalculateProductionTable(limit int64) <span class="cov0" title="0">{
        b.productionTable = make([]int64, limit)

        for i := int64(0); i &lt; limit; i++ </span><span class="cov0" title="0">{
                base := b.BaseProduction * b.ProductionEquations.A * float64(i)
                power := math.Pow(b.ProductionEquations.B, float64(i)*b.ProductionEquations.C)
                b.productionTable[i] = int64(base * power)
        }</span>
}

func (b *BuildingStruct) PrecalculateCostTable(limit int64) <span class="cov0" title="0">{
        b.costTable = make([]ResourcesStruct, limit)

        for i := int64(0); i &lt; limit; i++ </span><span class="cov0" title="0">{
                factor := b.CostEquations.A * math.Pow(b.CostEquations.B, float64(i-1)*b.CostEquations.C)
                b.costTable[i] = ResourcesStruct{
                        Metal:   b.BaseCost.Metal * factor,
                        Silicon: b.BaseCost.Silicon * factor,
                        Uranium: b.BaseCost.Uranium * factor,
                        Energy:  b.BaseCost.Energy * factor,
                        Time:    time.Duration(float64(b.BaseCost.Time*time.Second) * factor),
                }
        }</span>
        <span class="cov0" title="0">fmt.Println(b.Name)
        fmt.Println(b.costTable[1])
        fmt.Println(b.costTable[2])
        fmt.Println("--")
        time.Now()</span>
}

func (b *BuildingStruct) GetCost(level int64) ResourcesStruct <span class="cov0" title="0">{
        return b.costTable[level]
}</span>

func (b *BuildingStruct) GetProduction(level int64) int64 <span class="cov0" title="0">{
        return b.productionTable[level]
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "encoding/json"
        "io/ioutil"
        "path/filepath"
)

func LoadFile(file string, target interface{}) error <span class="cov8" title="1">{
        path := filepath.Join(ROOT_DIR, file)

        // Get the config file
        config_file, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(config_file, target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "strings"
)

type BaseDataStore struct {
        Buildings map[string]*BuildingStruct
        Research  map[string]*ResearchStruct
}

func NewBaseDataStore(buildings, research string) *BaseDataStore <span class="cov0" title="0">{
        store := &amp;BaseDataStore{}

        store.Buildings = make(map[string]*BuildingStruct)
        if err := LoadFile(buildings, &amp;store.Buildings); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">store.Research = make(map[string]*ResearchStruct)
        if err := LoadFile(buildings, &amp;store.Research); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">store.ExtractMineKeys()
        store.PrecalculateCostsAndProduction()

        return store</span>
}

func (b *BaseDataStore) FindMineByType(produces string) string <span class="cov0" title="0">{
        for key, building := range b.Buildings </span><span class="cov0" title="0">{
                if strings.EqualFold(building.Category, MineCategoryString) &amp;&amp;
                        strings.EqualFold(building.Produces, produces) </span><span class="cov0" title="0">{
                        return key
                }</span>
        }
        <span class="cov0" title="0">panic(ErrorMineNotFound)</span>
}

func (b *BaseDataStore) ExtractMineKeys() <span class="cov0" title="0">{
        MetalMineKey = b.FindMineByType(MetalMineCategoryKey)
        SiliconMineKey = b.FindMineByType(SiliconMineCategoryKey)
        UraniumMineKey = b.FindMineByType(UraniumMineCategoryKey)
        PowerPlantKey = b.FindMineByType(PowerPlantCategoryKey)
}</span>

func (b *BaseDataStore) PrecalculateCostsAndProduction() <span class="cov0" title="0">{
        for _, building := range b.Buildings </span><span class="cov0" title="0">{
                building.PrecalculateCostTable(PrecalculateLevels)
                building.PrecalculateProductionTable(PrecalculateLevels)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "bitbucket.org/tidepayments/gohelpers/tokens"
        "strings"
        "sync"
)

type PlayerDataStore struct {
        Players map[string]*PlayerStruct
        m       sync.RWMutex
}

func NewPlayerDataStore(file string) *PlayerDataStore <span class="cov8" title="1">{
        store := &amp;PlayerDataStore{
                Players: make(map[string]*PlayerStruct),
        }
        if err := LoadFile(file, &amp;store.Players); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return store</span>
}

func (p *PlayerDataStore) SafeAdd(player *PlayerStruct) <span class="cov8" title="1">{
        p.m.Lock()
        defer p.m.Unlock()

        var token string

        // Find a new random id
        for </span><span class="cov8" title="1">{
                token = &lt;-tokens.Token24
                if _, ok := p.Players[token]; !ok </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">player.ID = token
        p.Players[token] = player</span>
}

func (p *PlayerDataStore) SafeRemove(id string) <span class="cov0" title="0">{
        p.m.RLock()
        defer p.m.RUnlock()

        delete(p.Players, id)
}</span>

func (p *PlayerDataStore) SafeGet(id string) *PlayerStruct <span class="cov8" title="1">{
        p.m.RLock()
        defer p.m.RUnlock()

        return p.Players[id]
}</span>

func (p *PlayerDataStore) SafeGetByEmail(email string) *PlayerStruct <span class="cov0" title="0">{
        p.m.RLock()
        defer p.m.RUnlock()

        for _, player := range p.Players </span><span class="cov0" title="0">{
                if strings.EqualFold(email, player.Email) </span><span class="cov0" title="0">{
                        return player
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "github.com/gin-gonic/gin"
        "golang.org/x/crypto/bcrypt"
        "net/http"
)

type AccountHandler struct {
        RouterGroup *gin.RouterGroup
}

func (u *AccountHandler) Routes() <span class="cov0" title="0">{
        u.RouterGroup.POST("/login", gin.Bind(LoginStruct{}), u.LoginHandler)
        u.RouterGroup.POST("/register", gin.Bind(PlayerStruct{}), u.RegisterHandler)
}</span>

func NewAccountHandler(r *gin.RouterGroup) *AccountHandler <span class="cov0" title="0">{
        u := &amp;AccountHandler{RouterGroup: r}
        u.Routes()
        return u
}</span>

func (u *AccountHandler) LoginHandler(c *gin.Context) <span class="cov0" title="0">{
        var player *PlayerStruct

        login := c.MustGet(gin.BindKey).(*LoginStruct)

        if player = PlayerData.SafeGetByEmail(login.Email); player == nil </span><span class="cov0" title="0">{
                c.AbortWithError(http.StatusUnauthorized, ErrorInvalidCredentials).SetType(gin.ErrorTypePublic)
                return
        }</span>

        <span class="cov0" title="0">if err := player.CheckPassword(login.Password); err != nil </span><span class="cov0" title="0">{
                if err == bcrypt.ErrMismatchedHashAndPassword </span><span class="cov0" title="0">{
                        c.AbortWithError(http.StatusUnauthorized, ErrorInvalidCredentials).SetType(gin.ErrorTypePublic)
                }</span><span class="cov0" title="0"> else {
                        c.AbortWithError(http.StatusInternalServerError, err)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">u.sendLoginToken(c, player)</span>

}

func (u *AccountHandler) RegisterHandler(c *gin.Context) <span class="cov0" title="0">{
        player := c.MustGet(gin.BindKey).(*PlayerStruct)

        if err := player.HashPassword(); err != nil </span><span class="cov0" title="0">{
                c.AbortWithError(http.StatusBadRequest, err)
                return
        }</span>

        // Make sure this email hasn't been used yet
        <span class="cov0" title="0">if PlayerData.SafeGetByEmail(player.Email) != nil </span><span class="cov0" title="0">{
                c.AbortWithError(http.StatusBadRequest, ErrorEmailInUse).SetType(gin.ErrorTypePublic)
                return
        }</span>

        <span class="cov0" title="0">PlayerData.SafeAdd(player)

        // We have a player, let's make him a planet!
        planet, err := GenerateNewPlanet(Universe, BaseData)
        if err != nil </span><span class="cov0" title="0">{
                PlayerData.SafeRemove(player.ID)
                c.AbortWithError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">player.AddPlanet(planet)

        u.sendLoginToken(c, player)</span>
}

func (u *AccountHandler) sendLoginToken(c *gin.Context, player *PlayerStruct) <span class="cov0" title="0">{
        if token, err := player.CreateLoginToken(); err != nil </span><span class="cov0" title="0">{
                c.AbortWithError(http.StatusInternalServerError, err)
        }</span><span class="cov0" title="0"> else {
                c.JSON(http.StatusOK, gin.H{"Token": token})
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "github.com/gin-gonic/gin"
        "net/http"
        "time"
)

type PlanetHandler struct {
        RouterGroup *gin.RouterGroup
}

type PlanetRenameForm struct {
        Name string `form:"name" binding:"required,min=1,max=60"`
}

func (p *PlanetHandler) Routes() <span class="cov0" title="0">{
        p.RouterGroup.Use(PlayerMiddleware(PlayerData))
        p.RouterGroup.GET("/:id", PlanetMiddleware(), p.Get)
        p.RouterGroup.POST("/:id/rename", PlanetMiddleware(), gin.Bind(PlanetRenameForm{}), p.Rename)
        p.RouterGroup.POST("/:id/building/build/:type", PlanetMiddleware(), p.BuildBuilding)
}</span>

func NewPlanetHandler(r *gin.RouterGroup) *PlanetHandler <span class="cov0" title="0">{
        p := &amp;PlanetHandler{RouterGroup: r}
        p.Routes()
        return p
}</span>

func (p *PlanetHandler) Get(c *gin.Context) <span class="cov0" title="0">{
        planet := c.MustGet(PlanetObjectKey).(*PlanetStruct)

        planet.UpdatePlanet(BaseData, time.Now())
        c.JSON(http.StatusOK, planet.ToPublic(true))
}</span>

func (p *PlanetHandler) Rename(c *gin.Context) <span class="cov0" title="0">{
        planet := c.MustGet(PlanetObjectKey).(*PlanetStruct)
        rename := c.MustGet(gin.BindKey).(*PlanetRenameForm)
        planet.Name = rename.Name

        c.JSON(http.StatusOK, planet.ToPublic(true))
}</span>

func (p *PlanetHandler) BuildBuilding(c *gin.Context) <span class="cov0" title="0">{
        planet := c.MustGet(PlanetObjectKey).(*PlanetStruct)
        building_id := c.Params.ByName("type")

        if err := planet.BuildBuilding(BaseData, building_id); err != nil </span><span class="cov0" title="0">{
                c.AbortWithError(http.StatusBadRequest, err).SetType(gin.ErrorTypePublic)
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{})</span>

}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "github.com/gin-gonic/gin"
        "net/http"
)

type PlayerHandler struct {
        RouterGroup *gin.RouterGroup
}

func (p *PlayerHandler) Routes() <span class="cov0" title="0">{
        p.RouterGroup.Use(PlayerMiddleware(PlayerData))
        p.RouterGroup.GET("", p.Get)
        p.RouterGroup.GET("/data", p.GetData)
}</span>

func NewPlayerHandler(r *gin.RouterGroup) *PlayerHandler <span class="cov0" title="0">{
        p := &amp;PlayerHandler{RouterGroup: r}
        p.Routes()
        return p
}</span>

func (p *PlayerHandler) Get(c *gin.Context) <span class="cov0" title="0">{
        player := c.MustGet(PlayerObjectKey).(*PlayerStruct)

        c.JSON(http.StatusOK, player.ToPublic(true))
}</span>

func (p *PlayerHandler) GetData(c *gin.Context) <span class="cov0" title="0">{

        c.JSON(http.StatusOK, BaseData)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "github.com/nazwa/galaxy-empires/middleware"
        debug "bitbucket.org/tidepayments/gohelpers/gin"
        "github.com/gin-gonic/gin"
        "github.com/kardianos/osext"
)

var (
        ROOT_DIR   string
        BaseData   *BaseDataStore
        PlayerData *PlayerDataStore
        Universe   *UniverseStruct
        JWTKey     []byte = []byte("This is a key")
)

func main() <span class="cov0" title="0">{
        Universe = NewUniverseStruct(1, 15, 5)

        ROOT_DIR, _ = osext.ExecutableFolder()

        BaseData = NewBaseDataStore("data/buildings.json", "data/research.json")
        PlayerData = NewPlayerDataStore("data/players.json")

        r := gin.New()
        r.Use(gin.Logger())
        r.Use(gin.Recovery())
        r.Use(middleware.Errors("", "", nil))

        debug.AssignDebugHandlers(r.Group("/debug"))

        NewAccountHandler(r.Group("/account"))
        NewPlayerHandler(r.Group("/player", middleware.Authentication(JWTKey)))
        NewPlanetHandler(r.Group("/planet", middleware.Authentication(JWTKey)))

        r.Static("/assets", ROOT_DIR+"/web/assets")
        r.StaticFile("/", ROOT_DIR+"/web/index.html")

        if err := r.Run(":8080"); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
)

// This method checks if enpoints are logged in
func PlanetMiddleware() gin.HandlerFunc <span class="cov8" title="1">{

        return func(c *gin.Context) </span><span class="cov8" title="1">{
                player := c.MustGet(PlayerObjectKey).(*PlayerStruct)

                id, err := strconv.ParseInt(c.Params.ByName("id"), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        c.AbortWithError(http.StatusBadRequest, err).SetType(gin.ErrorTypePublic)
                        return
                }</span>

                <span class="cov8" title="1">planet := player.GetPlanet(id)
                if planet == nil </span><span class="cov8" title="1">{
                        c.AbortWithError(http.StatusBadRequest, ErrorInvalidPlanetID).SetType(gin.ErrorTypePublic)
                        return
                }</span>
                <span class="cov8" title="1">c.Set(PlanetObjectKey, planet)</span>

        }

}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "github.com/gin-gonic/gin"
        "github.com/nazwa/galaxy-empires/middleware"
        "net/http"
)

// This method checks if enpoints are logged in
func PlayerMiddleware(players *PlayerDataStore) gin.HandlerFunc <span class="cov8" title="1">{

        // Make sure we have players. It's OK to panic at this stage
        if players == nil </span><span class="cov8" title="1">{
                panic(ErrorPlayerDatabaseMissing)</span>
        }

        <span class="cov8" title="1">return func(c *gin.Context) </span><span class="cov8" title="1">{
                id := c.MustGet(middleware.AuthUserIDKey).(string)
                if player := players.SafeGet(id); player == nil </span><span class="cov8" title="1">{
                        c.AbortWithError(http.StatusInternalServerError, ErrorPlayerNotFound).SetType(gin.ErrorTypePublic)
                        return
                }</span><span class="cov8" title="1"> else {
                        c.Set(PlayerObjectKey, player)
                }</span>
        }

}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "sync"
        "time"
)

type CoordinatesStruct struct {
        Galaxy int64
        System int64
        Planet int64
}

type PlanetStruct struct {
        Position CoordinatesStruct
        Owner    *PlayerStruct

        Resources           ResourcesStruct
        ResourcesHourly     ResourcesStruct
        ResourcesUpdateTime time.Time
        ResourcesMutex      sync.Mutex

        Name string

        Research  map[string]int64
        Buildings map[string]int64

        BuildingInProgress      *BuildingProgressStruct
        BuildingInProgressMutex sync.Mutex
}

func GenerateNewPlanet(universe *UniverseStruct, baseData *BaseDataStore) (*PlanetStruct, error) <span class="cov0" title="0">{
        position, err := universe.GetNewCoordinates()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">planet := &amp;PlanetStruct{}
        planet.Position = *position
        planet.Name = DefaultPlanetName
        planet.Buildings = make(map[string]int64)

        // Set basic mine levels
        planet.Buildings[MetalMineKey] = 2
        planet.Buildings[SiliconMineKey] = 1
        planet.Buildings[UraniumMineKey] = 0
        planet.Buildings[PowerPlantKey] = 0

        // Set basic mine levels
        planet.Research = make(map[string]int64)
        planet.Resources = ResourcesStruct{
                Metal:   1000,
                Silicon: 1000,
                Uranium: 0,
                Energy:  0,
        }
        planet.ResourcesUpdateTime = time.Now()
        planet.UpdateHourlyProduction(baseData)

        universe.AddPlanet(position, planet)

        return planet, nil</span>
}

func (p *PlanetStruct) UpdatePlanet(baseData *BaseDataStore, now time.Time) <span class="cov0" title="0">{
        // Make sure no mines have been built while we were away
        // This will recalculate resources up to the time of the construction end
        p.UpdateConstruction(baseData, now)

        // Recalculate resources for real now
        p.RecalculateResources(baseData, now)
}</span>

func (p *PlanetStruct) RecalculateResources(baseData *BaseDataStore, now time.Time) <span class="cov0" title="0">{
        p.ResourcesMutex.Lock()
        defer p.ResourcesMutex.Unlock()

        timeDiff := now.Sub(p.ResourcesUpdateTime)
        // We dont want to udpate resources more often than this time
        if timeDiff &lt; MinimumResourceTime </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p.Resources.Metal += p.CalculateProduction(p.ResourcesHourly.Metal, timeDiff)
        p.Resources.Silicon += p.CalculateProduction(p.ResourcesHourly.Silicon, timeDiff)
        p.Resources.Uranium += p.CalculateProduction(p.ResourcesHourly.Uranium, timeDiff)

        p.ResourcesUpdateTime = now</span>
}

func (p *PlanetStruct) CalculateProduction(production float64, timeDiff time.Duration) float64 <span class="cov0" title="0">{
        return production / 3600 * timeDiff.Seconds()
}</span>

func (p *PlanetStruct) UpdateHourlyProduction(baseData *BaseDataStore) <span class="cov0" title="0">{
        p.ResourcesHourly = ResourcesStruct{
                Metal:   float64(baseData.Buildings[MetalMineKey].GetProduction(p.Buildings[MetalMineKey])),
                Silicon: float64(baseData.Buildings[SiliconMineKey].GetProduction(p.Buildings[SiliconMineKey])),
                Uranium: float64(baseData.Buildings[UraniumMineKey].GetProduction(p.Buildings[UraniumMineKey])),
        }
}</span>

func (p *PlanetStruct) SubtractResources(resources ResourcesStruct) error <span class="cov0" title="0">{
        p.ResourcesMutex.Lock()
        defer p.ResourcesMutex.Unlock()

        if !p.Resources.HasEnoughBasic(resources) </span><span class="cov0" title="0">{
                return ErrorInsufficientResources
        }</span>

        <span class="cov0" title="0">p.Resources.SubtractBasic(resources)

        return nil</span>
}

// Checks if there are any buildings that have finished
// Recalculates resources before completition
// @todo: FIRE EVENT TO NOTIFY BUILDING COMPLETITION
func (p *PlanetStruct) UpdateConstruction(baseData *BaseDataStore, now time.Time) <span class="cov0" title="0">{
        p.BuildingInProgressMutex.Lock()
        defer p.BuildingInProgressMutex.Unlock()

        if p.BuildingInProgress == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Triggers if building end time has already passed
        <span class="cov0" title="0">if p.BuildingInProgress.EndTime.Sub(now) &lt; 0 </span><span class="cov0" title="0">{
                // Recalculate the resources with old levels
                p.RecalculateResources(baseData, p.BuildingInProgress.EndTime)

                // Finish the actual build
                p.Buildings[p.BuildingInProgress.Building.ID]++
                p.BuildingInProgress = nil
                p.UpdateHourlyProduction(baseData)
        }</span>
}

func (p *PlanetStruct) BuildBuilding(baseData *BaseDataStore, id string) error <span class="cov0" title="0">{
        p.BuildingInProgressMutex.Lock()
        defer p.BuildingInProgressMutex.Unlock()

        if p.BuildingInProgress != nil </span><span class="cov0" title="0">{
                return ErrorBuildingInProgress
        }</span>

        <span class="cov0" title="0">var building *BuildingStruct
        var toLevel int64
        var ok bool

        if building, ok = baseData.Buildings[id]; !ok </span><span class="cov0" title="0">{
                return ErrorInvalidBuildingID
        }</span>

        <span class="cov0" title="0">if toLevel, ok = p.Buildings[id]; !ok </span><span class="cov0" title="0">{
                toLevel = 1
        }</span><span class="cov0" title="0"> else {
                toLevel++
        }</span>

        <span class="cov0" title="0">cost := building.GetCost(toLevel)

        if err := p.SubtractResources(cost); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">p.BuildingInProgress = &amp;BuildingProgressStruct{
                Building:  building,
                Cost:      cost,
                StartTime: time.Now(),
                EndTime:   time.Now().Add(cost.Time),
        }

        return nil</span>

}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        jwt "github.com/dgrijalva/jwt-go"
        "golang.org/x/crypto/bcrypt"
        "sync"
        "time"
)

const (
        BCRYPT_COMPLEXITY int = 12
)

type PlayerStruct struct {
        planetMutex sync.Mutex `json:"-"`

        ID       string `binding:"omitempty,number"`
        Name     string `form:"name" binding:"required,min=1,max=60"`
        Email    string `form:"email" binding:"required,email"`
        Password string `form:"password" binding:"required,min=5,max=60" json:"-"`
        Planets  []*PlanetStruct
}

type LoginStruct struct {
        Email    string `form:"email" binding:"required,email"`
        Password string `form:"password" binding:"max=200"`
}

func (p *PlayerStruct) GenerateHash(text string) (string, error) <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword([]byte(text), BCRYPT_COMPLEXITY)
        return string(hash), err
}</span>
func (p *PlayerStruct) HashPassword() error <span class="cov0" title="0">{
        hashedPassword, err := p.GenerateHash(p.Password)
        if err == nil </span><span class="cov0" title="0">{
                p.Password = hashedPassword
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (p *PlayerStruct) CreateLoginToken() (string, error) <span class="cov0" title="0">{

        token := jwt.New(jwt.SigningMethodHS256)
        // Set some claims
        token.Claims["id"] = p.ID
        token.Claims["exp"] = time.Now().Add(time.Hour * 1).Unix()
        // Sign and get the complete encoded token as a string
        return token.SignedString(JWTKey)

}</span>

func (p *PlayerStruct) CheckPassword(password string) error <span class="cov0" title="0">{
        return bcrypt.CompareHashAndPassword([]byte(p.Password), []byte(password))
}</span>

func (p *PlayerStruct) AddPlanet(planet *PlanetStruct) <span class="cov8" title="1">{
        if planet == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if planet.Owner == p </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">p.planetMutex.Lock()
        defer p.planetMutex.Unlock()

        if p.Planets == nil </span><span class="cov8" title="1">{
                p.Planets = make([]*PlanetStruct, 0)
        }</span>
        <span class="cov8" title="1">planet.Owner = p
        p.Planets = append(p.Planets, planet)</span>
}

func (p *PlayerStruct) GetPlanet(id int64) *PlanetStruct <span class="cov8" title="1">{
        p.planetMutex.Lock()
        defer p.planetMutex.Unlock()

        if p.Planets == nil </span><span class="cov0" title="0">{
                p.Planets = make([]*PlanetStruct, 0)
        }</span>
        <span class="cov8" title="1">if id &gt; int64(len(p.Planets)) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return p.Planets[id]</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

func (p *PlanetStruct) ToPublic(private bool) map[string]interface{} <span class="cov0" title="0">{
        data := make(map[string]interface{})

        data["Position"] = p.Position
        data["Owner"] = p.Owner.ID
        data["Name"] = p.Name
        // Only show private data if planet is owned by current player
        if private </span><span class="cov0" title="0">{
                data["Resources"] = p.Resources
                data["ResourcesHourly"] = p.ResourcesHourly
                data["Buildings"] = p.Buildings
                data["Research"] = p.Research
                data["BuildingProgress"] = p.BuildingInProgress
        }</span>

        <span class="cov0" title="0">return data</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package main

func (p *PlayerStruct) ToPublic(private bool) map[string]interface{} <span class="cov0" title="0">{
        data := make(map[string]interface{})

        data["Name"] = p.Name

        if private </span><span class="cov0" title="0">{
                data["Email"] = p.Email
                p.planetMutex.Lock()
                defer p.planetMutex.Unlock()
                planets := make([]map[string]interface{}, len(p.Planets))
                for i := range p.Planets </span><span class="cov0" title="0">{
                        planets[i] = p.Planets[i].ToPublic(private)
                }</span>
                <span class="cov0" title="0">data["Planets"] = planets</span>
        }

        <span class="cov0" title="0">return data</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package main

import (
        "time"
)

type ResourcesStruct struct {
        Metal   float64
        Silicon float64
        Uranium float64
        Energy  float64
        Time    time.Duration
}

type EquationStruct struct {
        A float64 `json:"a"`
        B float64 `json:"b"`
        C float64 `json:"c"`
}

func (r *ResourcesStruct) HasEnoughBasic(other ResourcesStruct) bool <span class="cov8" title="1">{
        return r.Metal &gt;= other.Metal &amp;&amp;
                r.Silicon &gt;= other.Silicon &amp;&amp;
                r.Uranium &gt;= other.Uranium
}</span>

func (r *ResourcesStruct) SubtractBasic(other ResourcesStruct) <span class="cov8" title="1">{
        r.Metal -= other.Metal
        r.Silicon -= other.Silicon
        r.Uranium -= other.Uranium
}</span>

func (r *ResourcesStruct) HasEnoughFull(other ResourcesStruct) bool <span class="cov8" title="1">{
        return r.Metal &gt;= other.Metal &amp;&amp;
                r.Silicon &gt;= other.Silicon &amp;&amp;
                r.Uranium &gt;= other.Uranium &amp;&amp;
                r.Energy &gt;= other.Energy &amp;&amp;
                r.Time &gt;= other.Time
}</span>
func (r *ResourcesStruct) SubtractFull(other ResourcesStruct) <span class="cov8" title="1">{
        r.Metal -= other.Metal
        r.Silicon -= other.Silicon
        r.Uranium -= other.Uranium
        r.Energy -= other.Energy
        r.Time -= other.Time
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package main

import (
        "bitbucket.org/tidepayments/gohelpers/maths"
)

type UniverseStruct struct {
        galaxies   [][]GalaxySystemStruct
        size       CoordinatesStruct
        lastGalaxy int64
}

type GalaxySystemStruct struct {
        planets     []*PlanetStruct
        coordinates CoordinatesStruct
        count       int64
}

func NewUniverseStruct(galaxies, systems, planets int64) *UniverseStruct <span class="cov8" title="1">{
        universe := &amp;UniverseStruct{}
        universe.size = CoordinatesStruct{
                Galaxy: galaxies,
                System: systems,
                Planet: planets,
        }

        universe.galaxies = make([][]GalaxySystemStruct, galaxies)
        for i := range universe.galaxies </span><span class="cov8" title="1">{
                universe.galaxies[i] = make([]GalaxySystemStruct, systems)
                for j := range universe.galaxies[i] </span><span class="cov8" title="1">{
                        universe.galaxies[i][j].planets = make([]*PlanetStruct, planets)
                        universe.galaxies[i][j].count = 0
                        universe.galaxies[i][j].coordinates = CoordinatesStruct{
                                Galaxy: int64(i),
                                System: int64(j),
                        }
                }</span>
        }

        <span class="cov8" title="1">return universe</span>
}

func (g *UniverseStruct) GetSize() CoordinatesStruct <span class="cov0" title="0">{
        return g.size
}</span>

func (g *UniverseStruct) GetSystem(coord *CoordinatesStruct) *GalaxySystemStruct <span class="cov0" title="0">{
        return &amp;g.galaxies[coord.Galaxy][coord.System]
}</span>

func (g *UniverseStruct) GetPlanet(coord *CoordinatesStruct) *PlanetStruct <span class="cov8" title="1">{
        return g.galaxies[coord.Galaxy][coord.System].planets[coord.Planet]
}</span>

func (g *UniverseStruct) AddPlanet(coord *CoordinatesStruct, newPlanet *PlanetStruct) <span class="cov8" title="1">{
        g.galaxies[coord.Galaxy][coord.System].planets[coord.Planet] = newPlanet
        g.galaxies[coord.Galaxy][coord.System].count++
}</span>

func (g *UniverseStruct) GetEmptiestSystem() *GalaxySystemStruct <span class="cov8" title="1">{
        min := g.galaxies[0][0]

        for i := range g.galaxies </span><span class="cov8" title="1">{
                for j := range g.galaxies[i] </span><span class="cov8" title="1">{
                        if g.galaxies[i][j].count &lt; min.count </span><span class="cov8" title="1">{
                                min = g.galaxies[i][j]
                        }</span>
                }
        }
        <span class="cov8" title="1">return &amp;min</span>
}

func (g *UniverseStruct) GetNewCoordinates() (*CoordinatesStruct, error) <span class="cov8" title="1">{
        system := g.GetEmptiestSystem()

        positions := make([]int64, 0, 0)

        for i, planet := range system.planets </span><span class="cov8" title="1">{
                if planet == nil </span><span class="cov8" title="1">{
                        positions = append(positions, int64(i))
                }</span>
        }

        <span class="cov8" title="1">if len(positions) == 0 </span><span class="cov8" title="1">{
                return nil, ErrorUniverseFull
        }</span>
        <span class="cov8" title="1">index := maths.RandomBetweenInt(0, len(positions)-1)

        return &amp;CoordinatesStruct{
                Galaxy: system.coordinates.Galaxy,
                System: system.coordinates.System,
                Planet: positions[index],
        }, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
