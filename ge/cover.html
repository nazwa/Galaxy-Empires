
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com\nazwa\galaxy-empires\ge\building.go (36.4%)</option>
				
				<option value="file1">github.com\nazwa\galaxy-empires\ge\building_mine.go (87.5%)</option>
				
				<option value="file2">github.com\nazwa\galaxy-empires\ge\building_type.go (0.0%)</option>
				
				<option value="file3">github.com\nazwa\galaxy-empires\ge\data_base.go (0.0%)</option>
				
				<option value="file4">github.com\nazwa\galaxy-empires\ge\data_loader.go (75.0%)</option>
				
				<option value="file5">github.com\nazwa\galaxy-empires\ge\data_player.go (100.0%)</option>
				
				<option value="file6">github.com\nazwa\galaxy-empires\ge\ge.go (0.0%)</option>
				
				<option value="file7">github.com\nazwa\galaxy-empires\ge\planet.go (33.8%)</option>
				
				<option value="file8">github.com\nazwa\galaxy-empires\ge\planet_public_map.go (0.0%)</option>
				
				<option value="file9">github.com\nazwa\galaxy-empires\ge\player.go (0.0%)</option>
				
				<option value="file10">github.com\nazwa\galaxy-empires\ge\player_public_map.go (0.0%)</option>
				
				<option value="file11">github.com\nazwa\galaxy-empires\ge\research.go (0.0%)</option>
				
				<option value="file12">github.com\nazwa\galaxy-empires\ge\resources.go (72.2%)</option>
				
				<option value="file13">github.com\nazwa\galaxy-empires\ge\universe.go (93.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package ge

import (
        "math"
        "time"
)

// Constant IDs for different building types
const (
        BuildingTypeMine geBuildingType = iota + 1
        BuildingTypePower
        BuildingTypeStorage
        BuildingTypeGeneric
)

// List of basic building IDs
const (
        BuildingIdMineMetal geBuildingID = iota + 1
        BuildingIdMineSilicon
        BuildingIdMineUranium

        BuildingIdPowerPlant

        BuildingIdGenericFactory
        BuildingIdGenericShipyard
        BuildingIdGenericLab
        BuildingIdGenericCommand
)

type BuildingInterface interface {
        GetCost(level int64) ResourcesStruct
        GetId() geBuildingID
        PrecalculateCostTable(levels int64)
}

type BuildingStruct struct {
        ID   geBuildingID
        Type geBuildingType

        BaseCost     ResourcesStruct
        Requirements RequirementsStruct

        CostEquations EquationStruct

        costTable []ResourcesStruct
}

type BuildingLevelStruct struct {
        Building BuildingInterface
        Level    int64
}

func (b *BuildingLevelStruct) GetBuildingProduction() float64 <span class="cov8" title="1">{
        if b == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if mine, ok := b.Building.(BuildingMineInterface); ok </span><span class="cov8" title="1">{
                return float64(mine.GetProduction(b.Level))
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (b *BuildingStruct) PrecalculateCostTable(limit int64) <span class="cov0" title="0">{
        b.costTable = make([]ResourcesStruct, limit)

        for i := int64(0); i &lt; limit; i++ </span><span class="cov0" title="0">{
                factor := b.CostEquations.A * math.Pow(b.CostEquations.B, float64(i-1)*b.CostEquations.C)
                b.costTable[i] = ResourcesStruct{
                        Metal:   b.BaseCost.Metal * factor,
                        Silicon: b.BaseCost.Silicon * factor,
                        Uranium: b.BaseCost.Uranium * factor,
                        Energy:  b.BaseCost.Energy * factor,
                        Time:    time.Duration(float64(b.BaseCost.Time) * factor),
                }
        }</span>
}

func (b *BuildingStruct) GetId() geBuildingID <span class="cov0" title="0">{
        return b.ID
}</span>

func (b *BuildingStruct) GetCost(level int64) ResourcesStruct <span class="cov0" title="0">{
        return b.costTable[level]
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package ge

import (
        "math"
)

type BuildingMineInterface interface {
        PrecalculateProductionTable(limit int64)
        GetProduction(level int64) int64
}

type BuildingMineStruct struct {
        BuildingStruct

        baseProduction float64

        productionTable     []int64
        productionEquations EquationStruct
}

func (b *BuildingMineStruct) PrecalculateProductionTable(limit int64) <span class="cov8" title="1">{
        b.productionTable = make([]int64, limit)

        for i := int64(0); i &lt; limit; i++ </span><span class="cov8" title="1">{
                base := b.baseProduction + b.productionEquations.A*float64(i)
                power := math.Pow(b.productionEquations.B, float64(i)*b.productionEquations.C)
                b.productionTable[i] = int64(base * power)
        }</span>
}

func (b *BuildingMineStruct) GetProduction(level int64) int64 <span class="cov8" title="1">{
        if int64(len(b.productionTable)) &lt;= level </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return b.productionTable[level]</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package ge

import (
        "strconv"
)

type geBuildingType int64
type geBuildingID int64
type geBuildingsLevelMap map[geBuildingID]*BuildingLevelStruct

// Converts string into geBuildingType
func BuildingTypeFromString(val string) (geBuildingType, error) <span class="cov0" title="0">{
        if buildingType, err := strconv.ParseInt(val, 10, 64); err == nil </span><span class="cov0" title="0">{
                return geBuildingType(buildingType), nil
        }</span>
        <span class="cov0" title="0">return 0, ErrorInvalidBuildingType</span>
}

// Converts string into geBuildingID
func BuildingIdFromString(val string) (geBuildingID, error) <span class="cov0" title="0">{
        if buildingId, err := strconv.ParseInt(val, 10, 64); err == nil </span><span class="cov0" title="0">{
                return geBuildingID(buildingId), nil
        }</span>
        <span class="cov0" title="0">return 0, ErrorInvalidBuildingID</span>
}

func (i *geBuildingID) String() string <span class="cov0" title="0">{
        return strconv.FormatInt(int64(*i), 10)
}</span>

// Simplifies the buildings list to only a map of levels for each building.
// Nothing else is needed
func (g *geBuildingsLevelMap) SimplifiedLevels() map[string]int64 <span class="cov0" title="0">{
        levels := make(map[string]int64)
        for id, data := range *g </span><span class="cov0" title="0">{
                levels[id.String()] = data.Level
        }</span>
        <span class="cov0" title="0">return levels</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package ge

import (
        "time"
)

type BaseDataStore struct {
        Buildings map[geBuildingID]BuildingInterface
        Research  map[string]*ResearchStruct
}

func NewBaseDataStore(buildings, research string) *BaseDataStore <span class="cov0" title="0">{
        store := &amp;BaseDataStore{}

        store.Buildings = make(map[geBuildingID]BuildingInterface) /*
                if err := LoadFile(buildings, &amp;store.Buildings); err != nil {
                        panic(err)
                }*/
        store.LoadStartingBuildings()
        store.Research = make(map[string]*ResearchStruct)
        if err := LoadFile(buildings, &amp;store.Research); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">store.PrecalculateCostsAndProduction()

        return store</span>
}

func (b *BaseDataStore) PrecalculateCostsAndProduction() <span class="cov0" title="0">{
        for _, building := range b.Buildings </span><span class="cov0" title="0">{
                if build, ok := building.(BuildingInterface); ok </span><span class="cov0" title="0">{
                        build.PrecalculateCostTable(PrecalculateLevels)
                }</span>

                <span class="cov0" title="0">if mine, ok := building.(BuildingMineInterface); ok </span><span class="cov0" title="0">{
                        mine.PrecalculateProductionTable(PrecalculateLevels)
                }</span>
        }
}

func (b *BaseDataStore) GetStartingBuildings() map[geBuildingID]*BuildingLevelStruct <span class="cov0" title="0">{
        list := make(map[geBuildingID]*BuildingLevelStruct)
        for id, building := range b.Buildings </span><span class="cov0" title="0">{
                list[id] = &amp;BuildingLevelStruct{
                        Building: building,
                        Level:    0,
                }
        }</span>

        <span class="cov0" title="0">return list</span>
}

func (b *BaseDataStore) LoadStartingBuildings() <span class="cov0" title="0">{
        b.Buildings[BuildingIdMineMetal] = &amp;BuildingMineStruct{
                BuildingStruct: BuildingStruct{
                        ID:            BuildingIdMineMetal,
                        BaseCost:      ResourcesStruct{30, 20, 0, 0, 10 * time.Second},
                        CostEquations: EquationStruct{1, 1.5, 1},
                },
                productionEquations: EquationStruct{1, 1.1, 1},
                baseProduction:      100,
        }
        b.Buildings[BuildingIdMineSilicon] = &amp;BuildingMineStruct{
                BuildingStruct: BuildingStruct{
                        ID:            BuildingIdMineSilicon,
                        BaseCost:      ResourcesStruct{30, 20, 0, 0, 10 * time.Second},
                        CostEquations: EquationStruct{1, 1.5, 1},
                },
                productionEquations: EquationStruct{1, 1.1, 1},
                baseProduction:      50,
        }
        b.Buildings[BuildingIdMineUranium] = &amp;BuildingMineStruct{
                BuildingStruct: BuildingStruct{
                        ID:            BuildingIdMineUranium,
                        BaseCost:      ResourcesStruct{30, 20, 0, 0, 10 * time.Second},
                        CostEquations: EquationStruct{1, 1.5, 1},
                },
                productionEquations: EquationStruct{1, 1.1, 1},
                baseProduction:      0,
        }
        b.Buildings[BuildingIdGenericFactory] = &amp;BuildingStruct{
                ID:            BuildingIdGenericFactory,
                BaseCost:      ResourcesStruct{30, 20, 0, 0, 10 * time.Second},
                CostEquations: EquationStruct{1, 1.5, 1},
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package ge

import (
        "encoding/json"
        "io/ioutil"
        "path/filepath"
)

func LoadFile(file string, target interface{}) error <span class="cov8" title="1">{
        // Get the config file
        data_file, err := ioutil.ReadFile(file)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data_file, target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func BuildFullPath(root, file string) string <span class="cov0" title="0">{
        return filepath.Join(root, file)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package ge

import (
        "bitbucket.org/tidepayments/gohelpers/tokens"
        "strings"
        "sync"
)

type PlayerDataStore struct {
        Players map[string]*PlayerStruct
        m       sync.RWMutex
}

func NewPlayerDataStore(file string) *PlayerDataStore <span class="cov8" title="1">{
        store := &amp;PlayerDataStore{
                Players: make(map[string]*PlayerStruct),
        }
        if err := LoadFile(file, &amp;store.Players); err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return store</span>
}

// Add generated the ID if necesary.
// Email is not used, not sure if thats a good approahc or not.
// Maybe email should be the ID? That would solve two problems in one go
// But then referencing parent b email everywhere is a bit silly
func (p *PlayerDataStore) SafeAdd(player *PlayerStruct) error <span class="cov8" title="1">{
        p.m.Lock()
        defer p.m.Unlock()

        // If player already has an ID, use it. This might be handy on data load
        if len(player.ID) != 0 </span><span class="cov8" title="1">{
                // Make sure that ID doesn't already exist
                if _, ok := p.Players[player.ID]; ok </span><span class="cov8" title="1">{
                        return ErrorPlayerIDInUse
                }</span>
        }<span class="cov8" title="1"> else {
                var token string
                // Generate a new random id
                for </span><span class="cov8" title="1">{
                        token = &lt;-tokens.Token24
                        if _, ok := p.Players[token]; !ok </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">player.ID = token</span>
        }
        <span class="cov8" title="1">p.Players[player.ID] = player
        return nil</span>
}

// @todo: This needs a lot of work. Should planets also be removed?
// What about all other lined assets?
// Is this the place to do it or will there be a command or something handling it?
func (p *PlayerDataStore) SafeRemove(id string) <span class="cov8" title="1">{
        p.m.RLock()
        defer p.m.RUnlock()

        delete(p.Players, id)
}</span>

func (p *PlayerDataStore) SafeGet(id string) *PlayerStruct <span class="cov8" title="1">{
        p.m.RLock()
        defer p.m.RUnlock()

        if player, ok := p.Players[id]; !ok </span><span class="cov8" title="1">{
                return nil
        }</span><span class="cov8" title="1"> else {
                return player
        }</span>
}

func (p *PlayerDataStore) SafeGetByEmail(email string) *PlayerStruct <span class="cov8" title="1">{
        p.m.RLock()
        defer p.m.RUnlock()

        for _, player := range p.Players </span><span class="cov8" title="1">{
                if strings.EqualFold(email, player.Email) </span><span class="cov8" title="1">{
                        return player
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package ge

import ()

type GalaxyEmpires struct {
        BaseData   *BaseDataStore
        PlayerData *PlayerDataStore
        Universe   *UniverseStruct
}

func NewGalaxyEmpires(dataDir string, universeSize CoordinatesStruct) *GalaxyEmpires <span class="cov0" title="0">{
        g := &amp;GalaxyEmpires{}

        g.PlayerData = NewPlayerDataStore(
                BuildFullPath(dataDir, "players.json"),
        )
        g.BaseData = NewBaseDataStore(
                BuildFullPath(dataDir, "buildings.json"),
                BuildFullPath(dataDir, "research.json"),
        )
        g.Universe = NewUniverseStruct(universeSize)

        return g

}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package ge

import (
        "sync"
        "time"
)

type CoordinatesStruct struct {
        Galaxy int64
        System int64
        Planet int64
}

type PlanetStruct struct {
        position CoordinatesStruct
        owner    *PlayerStruct

        resourcesMutex          sync.Mutex
        resources               ResourcesStruct
        hourlyResources         ResourcesStruct
        lastResourcesUpdateTime time.Time

        name string

        research  map[string]int64
        buildings geBuildingsLevelMap

        buildingInProgress      *BuildingProgressStruct
        buildingInProgressMutex sync.Mutex

        researchInProgress      *ResearchProgressStruct
        researchInProgressMutex sync.Mutex
}

func GenerateNewPlanet(universe *UniverseStruct, baseData *BaseDataStore) (*PlanetStruct, error) <span class="cov0" title="0">{
        position, err := universe.GetNewCoordinates()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">planet := &amp;PlanetStruct{}
        planet.position = *position
        planet.name = DefaultPlanetName
        planet.buildings = baseData.GetStartingBuildings()

        // Set basic mine levels
        planet.research = make(map[string]int64)
        planet.resources = ResourcesStruct{
                Metal:   1000,
                Silicon: 1000,
                Uranium: 0,
                Energy:  0,
        }
        planet.lastResourcesUpdateTime = time.Now()
        planet.UpdateHourlyProduction()

        universe.AddPlanet(position, planet)

        return planet, nil</span>
}

func (p *PlanetStruct) GetBuilding(id geBuildingID) *BuildingLevelStruct <span class="cov8" title="1">{
        if b, ok := p.buildings[id]; ok </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">return nil</span>

}

func (p *PlanetStruct) SetName(name string) <span class="cov8" title="1">{
        p.name = name
}</span>

func (p *PlanetStruct) UpdatePlanet(now time.Time) <span class="cov0" title="0">{
        // Make sure no mines have been built while we were away
        // This will recalculate resources up to the time of the construction end
        p.UpdateConstruction(now)

        // Recalculate resources for real now
        p.RecalculateResources(now)
}</span>

func (p *PlanetStruct) RecalculateResources(now time.Time) <span class="cov8" title="1">{
        p.resourcesMutex.Lock()
        defer p.resourcesMutex.Unlock()

        timeDiff := now.Sub(p.lastResourcesUpdateTime)
        // We dont want to udpate resources more often than this time
        if timeDiff &lt; MinimumResourceTime </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">p.resources.Metal += p.CalculateProductionSince(p.hourlyResources.Metal, timeDiff)
        p.resources.Silicon += p.CalculateProductionSince(p.hourlyResources.Silicon, timeDiff)
        p.resources.Uranium += p.CalculateProductionSince(p.hourlyResources.Uranium, timeDiff)

        p.lastResourcesUpdateTime = now</span>
}

// Calculates production of the resource during given time duration
func (p *PlanetStruct) CalculateProductionSince(production float64, timeDiff time.Duration) float64 <span class="cov8" title="1">{
        return production / 3600 * timeDiff.Seconds()
}</span>

// Updates cached production values for current mine levels
func (p *PlanetStruct) UpdateHourlyProduction() <span class="cov8" title="1">{
        p.hourlyResources = ResourcesStruct{
                Metal:   p.GetBuilding(BuildingIdMineMetal).GetBuildingProduction(),
                Silicon: p.GetBuilding(BuildingIdMineSilicon).GetBuildingProduction(),
                Uranium: p.GetBuilding(BuildingIdMineUranium).GetBuildingProduction(),
        }
}</span>

func (p *PlanetStruct) SubtractResources(resources ResourcesStruct) error <span class="cov8" title="1">{
        p.resourcesMutex.Lock()
        defer p.resourcesMutex.Unlock()

        if !p.resources.HasEnoughBasic(resources) </span><span class="cov8" title="1">{
                return ErrorInsufficientResources
        }</span>
        <span class="cov8" title="1">p.resources.SubtractBasic(resources)

        return nil</span>
}

//Adding should always be successful, so no need for errors! yay
func (p *PlanetStruct) AddResources(resources ResourcesStruct) <span class="cov8" title="1">{
        p.resourcesMutex.Lock()
        defer p.resourcesMutex.Unlock()

        p.resources.AddBasic(resources)
}</span>

// Checks if there are any buildings that have finished
// Recalculates resources before completition
// @todo: FIRE EVENT TO NOTIFY BUILDING COMPLETITION
func (p *PlanetStruct) UpdateConstruction(now time.Time) <span class="cov0" title="0">{
        p.buildingInProgressMutex.Lock()
        defer p.buildingInProgressMutex.Unlock()

        if p.buildingInProgress == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Triggers if building end time has already passed
        <span class="cov0" title="0">if p.buildingInProgress.EndTime.Sub(now) &lt; 0 </span><span class="cov0" title="0">{
                // Recalculate the resources with old levels
                p.RecalculateResources(p.buildingInProgress.EndTime)

                // Finish the actual build
                // This should NEVER EVER panic, but including it as a failsafe
                building := p.GetBuilding(p.buildingInProgress.Building.(BuildingInterface).GetId())
                if building == nil </span><span class="cov0" title="0">{
                        panic(ErrorInvalidBuildingID)</span>
                }
                <span class="cov0" title="0">building.Level++

                p.buildingInProgress = nil
                p.UpdateHourlyProduction()</span>
        }
}

func (p *PlanetStruct) BuildBuilding(id geBuildingID) error <span class="cov0" title="0">{
        p.buildingInProgressMutex.Lock()
        defer p.buildingInProgressMutex.Unlock()

        if p.buildingInProgress != nil </span><span class="cov0" title="0">{
                return ErrorBuildingInProgress
        }</span>

        <span class="cov0" title="0">current := p.GetBuilding(id)
        if current == nil </span><span class="cov0" title="0">{
                return ErrorInvalidBuildingID
        }</span>

        <span class="cov0" title="0">toLevel := current.Level + 1

        cost := current.Building.(BuildingInterface).GetCost(toLevel)

        if err := p.SubtractResources(cost); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">p.buildingInProgress = &amp;BuildingProgressStruct{
                Building:  current.Building,
                Cost:      cost,
                StartTime: time.Now(),
                EndTime:   time.Now().Add(cost.Time),
        }

        return nil</span>
}

func (p *PlanetStruct) CancelBuilding() <span class="cov0" title="0">{
        p.buildingInProgressMutex.Lock()
        defer p.buildingInProgressMutex.Unlock()

        if p.buildingInProgress == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p.AddResources(p.buildingInProgress.Cost)
        p.buildingInProgress = nil

        return</span>
}

/*
func (p *PlanetStruct) BuildResearch(baseData *BaseDataStore, id string) error {
        p.ResearchInProgressMutex.Lock()
        defer p.ResearchInProgressMutex.Unlock()

        if p.ResearchInProgress != nil {
                return ErrorResearchInProgress
        }

        var research *ResearchStruct
        var toLevel int64
        var ok bool

        if research, ok = baseData.Research[id]; !ok {
                return ErrorInvalidBuildingID
        }

        if toLevel, ok = p.Research[id]; !ok {
                toLevel = 1
        } else {
                toLevel++
        }

        cost := research.GetCost(toLevel)

        if err := p.SubtractResources(cost); err != nil {
                return err
        }

        p.ResearchInProgress = &amp;ResearchProgressStruct{
                Research:  research,
                Cost:      cost,
                StartTime: time.Now(),
                EndTime:   time.Now().Add(cost.Time),
        }

        return nil
}

func (p *PlanetStruct) CancelResearch() {
        p.ResearchInProgressMutex.Lock()
        defer p.ResearchInProgressMutex.Unlock()

        if p.ResearchInProgress == nil {
                return
        }

        p.AddResources(p.ResearchInProgress.Cost)
        p.ResearchInProgress = nil

        return
}*/
</pre>
		
		<pre class="file" id="file8" style="display: none">package ge

func (p *PlanetStruct) ToPublic(private bool) map[string]interface{} <span class="cov0" title="0">{
        data := make(map[string]interface{})

        data["Position"] = p.position
        data["Owner"] = p.owner.ID
        data["Name"] = p.name
        // Only show private data if planet is owned by current player
        if private </span><span class="cov0" title="0">{
                data["Resources"] = p.resources
                data["ResourcesHourly"] = p.hourlyResources
                data["Buildings"] = p.buildings.SimplifiedLevels()
                data["Research"] = p.research
                data["BuildingProgress"] = p.buildingInProgress
        }</span>

        <span class="cov0" title="0">return data</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package ge

import (
        "golang.org/x/crypto/bcrypt"
        "sync"
)

const (
        BCRYPT_COMPLEXITY int = 12
)

type PlayerStruct struct {
        planetMutex sync.Mutex `json:"-"`

        ID       string `binding:"omitempty,number"`
        Name     string `form:"name" binding:"required,min=1,max=60"`
        Email    string `form:"email" binding:"required,email"`
        Password string `form:"password" binding:"required,min=5,max=60" json:"-"`
        Planets  []*PlanetStruct
}

type LoginStruct struct {
        Email    string `form:"email" binding:"required,email"`
        Password string `form:"password" binding:"max=200"`
}

func (p *PlayerStruct) GenerateHash(text string) (string, error) <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword([]byte(text), BCRYPT_COMPLEXITY)
        return string(hash), err
}</span>
func (p *PlayerStruct) HashPassword() error <span class="cov0" title="0">{
        hashedPassword, err := p.GenerateHash(p.Password)
        if err == nil </span><span class="cov0" title="0">{
                p.Password = hashedPassword
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (p *PlayerStruct) CheckPassword(password string) error <span class="cov0" title="0">{
        return bcrypt.CompareHashAndPassword([]byte(p.Password), []byte(password))
}</span>

func (p *PlayerStruct) AddPlanet(planet *PlanetStruct) <span class="cov0" title="0">{
        if planet == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if planet.owner == p </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p.planetMutex.Lock()
        defer p.planetMutex.Unlock()

        if p.Planets == nil </span><span class="cov0" title="0">{
                p.Planets = make([]*PlanetStruct, 0)
        }</span>
        <span class="cov0" title="0">planet.owner = p
        p.Planets = append(p.Planets, planet)</span>
}

func (p *PlayerStruct) GetPlanet(id int64) *PlanetStruct <span class="cov0" title="0">{
        p.planetMutex.Lock()
        defer p.planetMutex.Unlock()

        if p.Planets == nil </span><span class="cov0" title="0">{
                p.Planets = make([]*PlanetStruct, 0)
        }</span>
        <span class="cov0" title="0">if id &gt; int64(len(p.Planets)) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return p.Planets[id]</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package ge

func (p *PlayerStruct) ToPublic(private bool) map[string]interface{} <span class="cov0" title="0">{
        data := make(map[string]interface{})

        data["Name"] = p.Name

        if private </span><span class="cov0" title="0">{
                data["Email"] = p.Email
                p.planetMutex.Lock()
                defer p.planetMutex.Unlock()
                planets := make([]map[string]interface{}, len(p.Planets))
                for i := range p.Planets </span><span class="cov0" title="0">{
                        planets[i] = p.Planets[i].ToPublic(private)
                }</span>
                <span class="cov0" title="0">data["Planets"] = planets</span>
        }

        <span class="cov0" title="0">return data</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package ge

import (
        "fmt"
        "math"
        "time"
)

type ResearchStruct struct {
        ID          string
        Name        string
        Category    string
        Description string
        BaseCost    ResourcesStruct

        CostEquations EquationStruct
        //BuildEqations       EquationStruct

        costTable []ResourcesStruct
}

func (r *ResearchStruct) PrecalculateCostTable(limit int64) <span class="cov0" title="0">{
        r.costTable = make([]ResourcesStruct, limit)

        for i := int64(0); i &lt; limit; i++ </span><span class="cov0" title="0">{
                factor := r.CostEquations.A * math.Pow(r.CostEquations.B, float64(i-1)*r.CostEquations.C)
                r.costTable[i] = ResourcesStruct{
                        Metal:   r.BaseCost.Metal * factor,
                        Silicon: r.BaseCost.Silicon * factor,
                        Uranium: r.BaseCost.Uranium * factor,
                        Energy:  r.BaseCost.Energy * factor,
                        Time:    time.Duration(float64(r.BaseCost.Time*time.Second) * factor),
                }
        }</span>
        <span class="cov0" title="0">fmt.Println(r.Name)
        fmt.Println(r.costTable[1])
        fmt.Println(r.costTable[2])
        fmt.Println("--")
        time.Now()</span>
}

func (r *ResearchStruct) GetCost(level int64) ResourcesStruct <span class="cov0" title="0">{
        return r.costTable[level]
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package ge

import (
        "time"
)

type ResourcesStruct struct {
        Metal   float64
        Silicon float64
        Uranium float64
        Energy  float64
        Time    time.Duration
}

type EquationStruct struct {
        A float64 `json:"a"`
        B float64 `json:"b"`
        C float64 `json:"c"`
}

func (r *ResourcesStruct) HasEnoughBasic(other ResourcesStruct) bool <span class="cov8" title="1">{
        return r.Metal &gt;= other.Metal &amp;&amp;
                r.Silicon &gt;= other.Silicon &amp;&amp;
                r.Uranium &gt;= other.Uranium
}</span>

func (r *ResourcesStruct) SubtractBasic(other ResourcesStruct) <span class="cov8" title="1">{
        r.Metal -= other.Metal
        r.Silicon -= other.Silicon
        r.Uranium -= other.Uranium
}</span>

func (r *ResourcesStruct) AddBasic(other ResourcesStruct) <span class="cov8" title="1">{
        r.Metal += other.Metal
        r.Silicon += other.Silicon
        r.Uranium += other.Uranium
}</span>

func (r *ResourcesStruct) HasEnoughFull(other ResourcesStruct) bool <span class="cov8" title="1">{
        return r.Metal &gt;= other.Metal &amp;&amp;
                r.Silicon &gt;= other.Silicon &amp;&amp;
                r.Uranium &gt;= other.Uranium &amp;&amp;
                r.Energy &gt;= other.Energy &amp;&amp;
                r.Time &gt;= other.Time
}</span>

func (r *ResourcesStruct) AddFull(other ResourcesStruct) <span class="cov0" title="0">{
        r.Metal += other.Metal
        r.Silicon += other.Silicon
        r.Uranium += other.Uranium
        r.Energy += other.Energy
        r.Time += other.Time
}</span>

func (r *ResourcesStruct) SubtractFull(other ResourcesStruct) <span class="cov8" title="1">{
        r.Metal -= other.Metal
        r.Silicon -= other.Silicon
        r.Uranium -= other.Uranium
        r.Energy -= other.Energy
        r.Time -= other.Time
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package ge

import (
        "bitbucket.org/tidepayments/gohelpers/maths"
)

type UniverseStruct struct {
        galaxies   [][]GalaxySystemStruct
        size       CoordinatesStruct
        lastGalaxy int64
}

type GalaxySystemStruct struct {
        planets     []*PlanetStruct
        coordinates CoordinatesStruct
        count       int64
}

func NewUniverseStruct(universeSize CoordinatesStruct) *UniverseStruct <span class="cov8" title="1">{
        universe := &amp;UniverseStruct{}
        universe.size = CoordinatesStruct{
                Galaxy: universeSize.Galaxy,
                System: universeSize.System,
                Planet: universeSize.Planet,
        }

        universe.galaxies = make([][]GalaxySystemStruct, universeSize.Galaxy)
        for i := range universe.galaxies </span><span class="cov8" title="1">{
                universe.galaxies[i] = make([]GalaxySystemStruct, universeSize.System)
                for j := range universe.galaxies[i] </span><span class="cov8" title="1">{
                        universe.galaxies[i][j].planets = make([]*PlanetStruct, universeSize.Planet)
                        universe.galaxies[i][j].count = 0
                        universe.galaxies[i][j].coordinates = CoordinatesStruct{
                                Galaxy: int64(i),
                                System: int64(j),
                        }
                }</span>
        }

        <span class="cov8" title="1">return universe</span>
}

func (g *UniverseStruct) GetSize() CoordinatesStruct <span class="cov0" title="0">{
        return g.size
}</span>

func (g *UniverseStruct) GetSystem(coord *CoordinatesStruct) *GalaxySystemStruct <span class="cov0" title="0">{
        return &amp;g.galaxies[coord.Galaxy][coord.System]
}</span>

func (g *UniverseStruct) GetPlanet(coord *CoordinatesStruct) *PlanetStruct <span class="cov8" title="1">{
        return g.galaxies[coord.Galaxy][coord.System].planets[coord.Planet]
}</span>

func (g *UniverseStruct) AddPlanet(coord *CoordinatesStruct, newPlanet *PlanetStruct) <span class="cov8" title="1">{
        g.galaxies[coord.Galaxy][coord.System].planets[coord.Planet] = newPlanet
        g.galaxies[coord.Galaxy][coord.System].count++
}</span>

func (g *UniverseStruct) GetEmptiestSystem() *GalaxySystemStruct <span class="cov8" title="1">{
        min := g.galaxies[0][0]

        for i := range g.galaxies </span><span class="cov8" title="1">{
                for j := range g.galaxies[i] </span><span class="cov8" title="1">{
                        if g.galaxies[i][j].count &lt; min.count </span><span class="cov8" title="1">{
                                min = g.galaxies[i][j]
                        }</span>
                }
        }
        <span class="cov8" title="1">return &amp;min</span>
}

func (g *UniverseStruct) GetNewCoordinates() (*CoordinatesStruct, error) <span class="cov8" title="1">{
        system := g.GetEmptiestSystem()

        positions := make([]int64, 0, 0)

        for i, planet := range system.planets </span><span class="cov8" title="1">{
                if planet == nil </span><span class="cov8" title="1">{
                        positions = append(positions, int64(i))
                }</span>
        }

        <span class="cov8" title="1">if len(positions) == 0 </span><span class="cov8" title="1">{
                return nil, ErrorUniverseFull
        }</span>
        <span class="cov8" title="1">index := maths.RandomBetweenInt(0, len(positions)-1)

        return &amp;CoordinatesStruct{
                Galaxy: system.coordinates.Galaxy,
                System: system.coordinates.System,
                Planet: positions[index],
        }, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
